<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c2{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c2 doc-content"><p class="c0"><span class="c1">PRACTICAL NO-1</span></p><p class="c0"><span class="c1">AIM: Implement Breadth first search algorithm for Romanian map problem.</span></p><p class="c0"><span class="c1">RMP.py</span></p><p class="c0"><span class="c1">dict_hn={&#39;Arad&#39;:336,&#39;Bucharest&#39;:0,&#39;Craiova&#39;:160,&#39;Drobeta&#39;:242,&#39;Eforie&#39;:161,</span></p><p class="c0"><span class="c1">&#39;Fagaras&#39;:176,&#39;Giurgiu&#39;:77,&#39;Hirsova&#39;:151,&#39;Iasi&#39;:226,&#39;Lugoj&#39;:244,</span></p><p class="c0"><span class="c1">&#39;Mehadia&#39;:241,&#39;Neamt&#39;:234,&#39;Oradea&#39;:380,&#39;Pitesti&#39;:100,&#39;Rimnicu&#39;:193,</span></p><p class="c0"><span class="c1">&#39;Sibiu&#39;:253,&#39;Timisoara&#39;:329,&#39;Urziceni&#39;:80,&#39;Vaslui&#39;:199,&#39;Zerind&#39;:374}</span></p><p class="c0"><span class="c1">dict_gn=dict(</span></p><p class="c0"><span class="c1">Arad=dict(Zerind=75,Timisoara=118,Sibiu=140),</span></p><p class="c0"><span class="c1">Bucharest=dict(Urziceni=85,Giurgiu=90,Pitesti=101,Fagaras=211),</span></p><p class="c0"><span class="c1">Craiova=dict(Drobeta=120,Pitesti=138,Rimnicu=146),</span></p><p class="c0"><span class="c1">Drobeta=dict(Mehadia=75,Craiova=120),</span></p><p class="c0"><span class="c1">Eforie=dict(Hirsova=86),</span></p><p class="c0"><span class="c1">Fagaras=dict(Sibiu=99,Bucharest=211),</span></p><p class="c0"><span class="c1">Giurgiu=dict(Bucharest=90),</span></p><p class="c0"><span class="c1">Hirsova=dict(Eforie=86,Urziceni=98),</span></p><p class="c0"><span class="c1">Iasi=dict(Neamt=87,Vaslui=92),</span></p><p class="c0"><span class="c1">Lugoj=dict(Mehadia=70,Timisoara=111),</span></p><p class="c0"><span class="c1">Mehadia=dict(Lugoj=70,Drobeta=75),</span></p><p class="c0"><span class="c1">Neamt=dict(Iasi=87),</span></p><p class="c0"><span class="c1">Oradea=dict(Zerind=71,Sibiu=151),</span></p><p class="c0"><span class="c1">Pitesti=dict(Rimnicu=97,Bucharest=101,Craiova=138),</span></p><p class="c0"><span class="c1">Rimnicu=dict(Sibiu=80,Pitesti=97,Craiova=146),</span></p><p class="c0"><span class="c1">Sibiu=dict(Rimnicu=80,Fagaras=99,Arad=140,Oradea=151),</span></p><p class="c0"><span class="c1">Timisoara=dict(Lugoj=111,Arad=118),</span></p><p class="c0"><span class="c1">Urziceni=dict(Bucharest=85,Hirsova=98,Vaslui=142),</span></p><p class="c0"><span class="c1">Vaslui=dict(Iasi=92,Urziceni=142),</span></p><p class="c0"><span class="c1">Zerind=dict(Oradea=71,Arad=75)</span></p><p class="c0"><span class="c1">)</span></p><p class="c0"><span class="c1">Prac1.py</span></p><p class="c0"><span class="c1">import queue as Q</span></p><p class="c0"><span class="c1">from RMP import dict_gn</span></p><p class="c0"><span class="c1">start=&#39;Arad&#39;</span></p><p class="c0"><span class="c1">goal=&#39;Bucharest&#39;</span></p><p class="c0"><span class="c1">result=&#39;&#39;</span></p><p class="c0"><span class="c1">def BFS(city, cityq, visitedq):</span></p><p class="c0"><span class="c1">global result</span></p><p class="c0"><span class="c1">if city==start:</span></p><p class="c0"><span class="c1">result=result+&#39; &#39;+city</span></p><p class="c0"><span class="c1">for eachcity in dict_gn[city].keys():</span></p><p class="c0"><span class="c1">if eachcity==goal:</span></p><p class="c0"><span class="c1">result=result+&#39; &#39;+eachcity</span></p><p class="c0"><span class="c1">return</span></p><p class="c0"><span class="c1">if eachcity not in cityq.queue and eachcity not in visitedq.queue:</span></p><p class="c0"><span class="c1">cityq.put(eachcity)</span></p><p class="c0"><span class="c1">result=result+&#39; &#39;+eachcity</span></p><p class="c0"><span class="c1">visitedq.put(city)</span></p><p class="c0"><span class="c1">BFS(cityq.get(),cityq,visitedq)</span></p><p class="c0"><span class="c1">def main():</span></p><p class="c0"><span class="c1">cityq=Q.Queue()</span></p><p class="c0"><span class="c1">visitedq=Q.Queue()</span></p><p class="c0"><span class="c1">BFS(start, cityq, visitedq)</span></p><p class="c0"><span class="c1">print(&quot;BFS Traversal from &quot;,start,&quot; to &quot;,goal,&quot; is: &quot;)</span></p><p class="c0"><span class="c1">print(result)</span></p><p class="c0"><span class="c1">main()</span></p><p class="c0"><span class="c1">OUTPUT:</span></p><p class="c0"><span class="c1">BFS Traversal from Arad to Bucharest is:</span></p><p class="c0"><span class="c1">Arad Timisoara Zerind Sibiu Lugoj Oradea Fagaras Rimnicu Mehadia Bucharest</span></p><p class="c0"><span class="c1">PRACTICAL NO-2</span></p><p class="c0"><span class="c1">AIM: Implement IDDFS(Iterative Deepening Depth-First Search).</span></p><p class="c0"><span class="c1">RMP.py</span></p><p class="c0"><span class="c1">dict_hn={&#39;Arad&#39;:336,&#39;Bucharest&#39;:0,&#39;Craiova&#39;:160,&#39;Drobeta&#39;:242,&#39;Eforie&#39;:161,</span></p><p class="c0"><span class="c1">&#39;Fagaras&#39;:176,&#39;Giurgiu&#39;:77,&#39;Hirsova&#39;:151,&#39;Iasi&#39;:226,&#39;Lugoj&#39;:244,</span></p><p class="c0"><span class="c1">&#39;Mehadia&#39;:241,&#39;Neamt&#39;:234,&#39;Oradea&#39;:380,&#39;Pitesti&#39;:100,&#39;Rimnicu&#39;:193,</span></p><p class="c0"><span class="c1">&#39;Sibiu&#39;:253,&#39;Timisoara&#39;:329,&#39;Urziceni&#39;:80,&#39;Vaslui&#39;:199,&#39;Zerind&#39;:374}</span></p><p class="c0"><span class="c1">dict_gn=dict(</span></p><p class="c0"><span class="c1">Arad=dict(Zerind=75,Timisoara=118,Sibiu=140),</span></p><p class="c0"><span class="c1">Bucharest=dict(Urziceni=85,Giurgiu=90,Pitesti=101,Fagaras=211),</span></p><p class="c0"><span class="c1">Craiova=dict(Drobeta=120,Pitesti=138,Rimnicu=146),</span></p><p class="c0"><span class="c1">Drobeta=dict(Mehadia=75,Craiova=120),</span></p><p class="c0"><span class="c1">Eforie=dict(Hirsova=86),</span></p><p class="c0"><span class="c1">Fagaras=dict(Sibiu=99,Bucharest=211),</span></p><p class="c0"><span class="c1">Giurgiu=dict(Bucharest=90),</span></p><p class="c0"><span class="c1">Hirsova=dict(Eforie=86,Urziceni=98),</span></p><p class="c0"><span class="c1">Iasi=dict(Neamt=87,Vaslui=92),</span></p><p class="c0"><span class="c1">Lugoj=dict(Mehadia=70,Timisoara=111),</span></p><p class="c0"><span class="c1">Mehadia=dict(Lugoj=70,Drobeta=75),</span></p><p class="c0"><span class="c1">Neamt=dict(Iasi=87),</span></p><p class="c0"><span class="c1">Oradea=dict(Zerind=71,Sibiu=151),</span></p><p class="c0"><span class="c1">Pitesti=dict(Rimnicu=97,Bucharest=101,Craiova=138),</span></p><p class="c0"><span class="c1">Rimnicu=dict(Sibiu=80,Pitesti=97,Craiova=146),</span></p><p class="c0"><span class="c1">Sibiu=dict(Rimnicu=80,Fagaras=99,Arad=140,Oradea=151),</span></p><p class="c0"><span class="c1">Timisoara=dict(Lugoj=111,Arad=118),</span></p><p class="c0"><span class="c1">Urziceni=dict(Bucharest=85,Hirsova=98,Vaslui=142),</span></p><p class="c0"><span class="c1">Vaslui=dict(Iasi=92,Urziceni=142),</span></p><p class="c0"><span class="c1">Zerind=dict(Oradea=71,Arad=75)</span></p><p class="c0"><span class="c1">)</span></p><p class="c0"><span class="c1">Prac2.py</span></p><p class="c0"><span class="c1">import queue as Q</span></p><p class="c0"><span class="c1">from RMP import dict_gn</span></p><p class="c0"><span class="c1">start=&#39;Arad&#39;</span></p><p class="c0"><span class="c1">goal=&#39;Bucharest&#39;</span></p><p class="c0"><span class="c1">result=&#39;&#39;</span></p><p class="c0"><span class="c1">def DLS(city, visitedstack, startlimit, endlimit):</span></p><p class="c0"><span class="c1">global result</span></p><p class="c0"><span class="c1">found=0</span></p><p class="c0"><span class="c1">result=result+city+&#39; &#39;</span></p><p class="c0"><span class="c1">visitedstack.append(city)</span></p><p class="c0"><span class="c1">if city==goal:</span></p><p class="c0"><span class="c1">return 1</span></p><p class="c0"><span class="c1">if startlimit==endlimit:</span></p><p class="c0"><span class="c1">return 0</span></p><p class="c0"><span class="c1">for eachcity in dict_gn[city].keys():</span></p><p class="c0"><span class="c1">if eachcity not in visitedstack:</span></p><p class="c0"><span class="c1">found=DLS(eachcity, visitedstack, startlimit+1, endlimit)</span></p><p class="c0"><span class="c1">if found:</span></p><p class="c0"><span class="c1">return found</span></p><p class="c0"><span class="c1">def IDDFS(city, visitedstack, endlimit):</span></p><p class="c0"><span class="c1">global result</span></p><p class="c0"><span class="c1">for i in range(0, endlimit):</span></p><p class="c0"><span class="c1">print(&quot;Searching at Limit: &quot;,i)</span></p><p class="c0"><span class="c1">found=DLS(city, visitedstack, 0, i)</span></p><p class="c0"><span class="c1">if found:</span></p><p class="c0"><span class="c1">print(&quot;Found&quot;)</span></p><p class="c0"><span class="c1">break</span></p><p class="c0"><span class="c1">else:</span></p><p class="c0"><span class="c1">print(&quot;Not Found! &quot;)</span></p><p class="c0"><span class="c1">print(result)</span></p><p class="c0"><span class="c1">print(&quot;-----&quot;)</span></p><p class="c0"><span class="c1">result=&#39; &#39;</span></p><p class="c0"><span class="c1">visitedstack=[]</span></p><p class="c0"><span class="c1">def main():</span></p><p class="c0"><span class="c1">visitedstack=[]</span></p><p class="c0"><span class="c1">IDDFS(start, visitedstack, 9)</span></p><p class="c0"><span class="c1">print(&quot;IDDFS Traversal from &quot;,start,&quot; to &quot;, goal,&quot; is: &quot;)</span></p><p class="c0"><span class="c1">print(result)</span></p><p class="c0"><span class="c1">main()</span></p><p class="c0"><span class="c1">OUTPUT:</span></p><p class="c0"><span class="c1">Searching at Limit: 0</span></p><p class="c0"><span class="c1">Not Found!</span></p><p class="c0"><span class="c1">Arad</span></p><p class="c0"><span class="c1">-----</span></p><p class="c0"><span class="c1">Searching at Limit: 1</span></p><p class="c0"><span class="c1">Not Found!</span></p><p class="c0"><span class="c1">Arad Zerind Sibiu Timisoara</span></p><p class="c0"><span class="c1">-----</span></p><p class="c0"><span class="c1">Searching at Limit: 2</span></p><p class="c0"><span class="c1">Not Found!</span></p><p class="c0"><span class="c1">Arad Zerind Oradea Sibiu Rimnicu Fagaras Timisoara Lugoj</span></p><p class="c0"><span class="c1">-----</span></p><p class="c0"><span class="c1">Searching at Limit: 3</span></p><p class="c0"><span class="c1">Not Found!</span></p><p class="c0"><span class="c1">Arad Zerind Oradea Sibiu Timisoara Lugoj Mehadia</span></p><p class="c0"><span class="c1">-----</span></p><p class="c0"><span class="c1">Searching at Limit: 4</span></p><p class="c0"><span class="c1">Not Found!</span></p><p class="c0"><span class="c1">Arad Zerind Oradea Sibiu Rimnicu Fagaras Timisoara Lugoj Mehadia Drobeta</span></p><p class="c0"><span class="c1">-----</span></p><p class="c0"><span class="c1">Searching at Limit: 5</span></p><p class="c0"><span class="c1">Found</span></p><p class="c0"><span class="c1">IDDFS Traversal from Arad to Bucharest is:</span></p><p class="c0"><span class="c1">Arad Zerind Oradea Sibiu Rimnicu Pitesti Craiova Fagaras Bucharest</span></p><p class="c0"><span class="c1">PRACTICAL NO-3</span></p><p class="c0"><span class="c1">AIM: Implement A* search.</span></p><p class="c0"><span class="c1">RMP.py</span></p><p class="c0"><span class="c1">dict_hn={&#39;Arad&#39;:336,&#39;Bucharest&#39;:0,&#39;Craiova&#39;:160,&#39;Drobeta&#39;:242,&#39;Eforie&#39;:161,</span></p><p class="c0"><span class="c1">&#39;Fagaras&#39;:176,&#39;Giurgiu&#39;:77,&#39;Hirsova&#39;:151,&#39;Iasi&#39;:226,&#39;Lugoj&#39;:244,</span></p><p class="c0"><span class="c1">&#39;Mehadia&#39;:241,&#39;Neamt&#39;:234,&#39;Oradea&#39;:380,&#39;Pitesti&#39;:100,&#39;Rimnicu&#39;:193,</span></p><p class="c0"><span class="c1">&#39;Sibiu&#39;:253,&#39;Timisoara&#39;:329,&#39;Urziceni&#39;:80,&#39;Vaslui&#39;:199,&#39;Zerind&#39;:374}</span></p><p class="c0"><span class="c1">dict_gn=dict(</span></p><p class="c0"><span class="c1">Arad=dict(Zerind=75,Timisoara=118,Sibiu=140),</span></p><p class="c0"><span class="c1">Bucharest=dict(Urziceni=85,Giurgiu=90,Pitesti=101,Fagaras=211),</span></p><p class="c0"><span class="c1">Craiova=dict(Drobeta=120,Pitesti=138,Rimnicu=146),</span></p><p class="c0"><span class="c1">Drobeta=dict(Mehadia=75,Craiova=120),</span></p><p class="c0"><span class="c1">Eforie=dict(Hirsova=86),</span></p><p class="c0"><span class="c1">Fagaras=dict(Sibiu=99,Bucharest=211),</span></p><p class="c0"><span class="c1">Giurgiu=dict(Bucharest=90),</span></p><p class="c0"><span class="c1">Hirsova=dict(Eforie=86,Urziceni=98),</span></p><p class="c0"><span class="c1">Iasi=dict(Neamt=87,Vaslui=92),</span></p><p class="c0"><span class="c1">Lugoj=dict(Mehadia=70,Timisoara=111),</span></p><p class="c0"><span class="c1">Mehadia=dict(Lugoj=70,Drobeta=75),</span></p><p class="c0"><span class="c1">Neamt=dict(Iasi=87),</span></p><p class="c0"><span class="c1">Oradea=dict(Zerind=71,Sibiu=151),</span></p><p class="c0"><span class="c1">Pitesti=dict(Rimnicu=97,Bucharest=101,Craiova=138),</span></p><p class="c0"><span class="c1">Rimnicu=dict(Sibiu=80,Pitesti=97,Craiova=146),</span></p><p class="c0"><span class="c1">Sibiu=dict(Rimnicu=80,Fagaras=99,Arad=140,Oradea=151),</span></p><p class="c0"><span class="c1">Timisoara=dict(Lugoj=111,Arad=118),</span></p><p class="c0"><span class="c1">Urziceni=dict(Bucharest=85,Hirsova=98,Vaslui=142),</span></p><p class="c0"><span class="c1">Vaslui=dict(Iasi=92,Urziceni=142),</span></p><p class="c0"><span class="c1">Zerind=dict(Oradea=71,Arad=75)</span></p><p class="c0"><span class="c1">)</span></p><p class="c0"><span class="c1">Prac3.py</span></p><p class="c0"><span class="c1">import queue as Q</span></p><p class="c0"><span class="c1">from RMP import dict_gn</span></p><p class="c0"><span class="c1">from RMP import dict_hn</span></p><p class="c0"><span class="c1">start=&#39;Arad&#39;</span></p><p class="c0"><span class="c1">goal=&#39;Bucharest&#39;</span></p><p class="c0"><span class="c1">result=&#39;&#39;</span></p><p class="c0"><span class="c1">def get_fn(citystr):</span></p><p class="c0"><span class="c1">cities=citystr.split(&quot; , &quot;)</span></p><p class="c0"><span class="c1">hn=gn=0</span></p><p class="c0"><span class="c1">for ctr in range(0, len(cities)-1):</span></p><p class="c0"><span class="c1">gn=gn+dict_gn[cities[ctr]][cities[ctr+1]]</span></p><p class="c0"><span class="c1">hn=dict_hn[cities[len(cities)-1]]</span></p><p class="c0"><span class="c1">return(hn+gn)</span></p><p class="c0"><span class="c1">def expand(cityq):</span></p><p class="c0"><span class="c1">global result</span></p><p class="c0"><span class="c1">tot, citystr, thiscity=cityq.get()</span></p><p class="c0"><span class="c1">if thiscity==goal:</span></p><p class="c0"><span class="c1">result=citystr+&quot; : : &quot;+str(tot)</span></p><p class="c0"><span class="c1">return</span></p><p class="c0"><span class="c1">for cty in dict_gn[thiscity]:</span></p><p class="c0"><span class="c1">cityq.put((get_fn(citystr+&quot; , &quot;+cty), citystr+&quot; , &quot;+cty, cty))</span></p><p class="c0"><span class="c1">expand(cityq)</span></p><p class="c0"><span class="c1">def main():</span></p><p class="c0"><span class="c1">cityq=Q.PriorityQueue()</span></p><p class="c0"><span class="c1">thiscity=start</span></p><p class="c0"><span class="c1">cityq.put((get_fn(start),start,thiscity))</span></p><p class="c0"><span class="c1">expand(cityq)</span></p><p class="c0"><span class="c1">print(&quot;The A* path with the total is: &quot;)</span></p><p class="c0"><span class="c1">print(result)</span></p><p class="c0"><span class="c1">main()</span></p><p class="c0"><span class="c1">OUTPUT:</span></p><p class="c0"><span class="c1">The A* path with the total is:</span></p><p class="c0"><span class="c1">Arad , Sibiu , Rimnicu , Pitesti , Bucharest : : 418</span></p><p class="c0"><span class="c1">PRACTICAL NO-4</span></p><p class="c0"><span class="c1">AIM: RBFS(Recursive Breadth First Search)</span></p><p class="c0"><span class="c1">RMP.py</span></p><p class="c0"><span class="c1">dict_hn={&#39;Arad&#39;:336,&#39;Bucharest&#39;:0,&#39;Craiova&#39;:160,&#39;Drobeta&#39;:242,&#39;Eforie&#39;:161,</span></p><p class="c0"><span class="c1">&#39;Fagaras&#39;:176,&#39;Giurgiu&#39;:77,&#39;Hirsova&#39;:151,&#39;Iasi&#39;:226,&#39;Lugoj&#39;:244,</span></p><p class="c0"><span class="c1">&#39;Mehadia&#39;:241,&#39;Neamt&#39;:234,&#39;Oradea&#39;:380,&#39;Pitesti&#39;:100,&#39;Rimnicu&#39;:193,</span></p><p class="c0"><span class="c1">&#39;Sibiu&#39;:253,&#39;Timisoara&#39;:329,&#39;Urziceni&#39;:80,&#39;Vaslui&#39;:199,&#39;Zerind&#39;:374}</span></p><p class="c0"><span class="c1">dict_gn=dict(</span></p><p class="c0"><span class="c1">Arad=dict(Zerind=75,Timisoara=118,Sibiu=140),</span></p><p class="c0"><span class="c1">Bucharest=dict(Urziceni=85,Giurgiu=90,Pitesti=101,Fagaras=211),</span></p><p class="c0"><span class="c1">Craiova=dict(Drobeta=120,Pitesti=138,Rimnicu=146),</span></p><p class="c0"><span class="c1">Drobeta=dict(Mehadia=75,Craiova=120),</span></p><p class="c0"><span class="c1">Eforie=dict(Hirsova=86),</span></p><p class="c0"><span class="c1">Fagaras=dict(Sibiu=99,Bucharest=211),</span></p><p class="c0"><span class="c1">Giurgiu=dict(Bucharest=90),</span></p><p class="c0"><span class="c1">Hirsova=dict(Eforie=86,Urziceni=98),</span></p><p class="c0"><span class="c1">Iasi=dict(Neamt=87,Vaslui=92),</span></p><p class="c0"><span class="c1">Lugoj=dict(Mehadia=70,Timisoara=111),</span></p><p class="c0"><span class="c1">Mehadia=dict(Lugoj=70,Drobeta=75),</span></p><p class="c0"><span class="c1">Neamt=dict(Iasi=87),</span></p><p class="c0"><span class="c1">Oradea=dict(Zerind=71,Sibiu=151),</span></p><p class="c0"><span class="c1">Pitesti=dict(Rimnicu=97,Bucharest=101,Craiova=138),</span></p><p class="c0"><span class="c1">Rimnicu=dict(Sibiu=80,Pitesti=97,Craiova=146),</span></p><p class="c0"><span class="c1">Sibiu=dict(Rimnicu=80,Fagaras=99,Arad=140,Oradea=151),</span></p><p class="c0"><span class="c1">Timisoara=dict(Lugoj=111,Arad=118),</span></p><p class="c0"><span class="c1">Urziceni=dict(Bucharest=85,Hirsova=98,Vaslui=142),</span></p><p class="c0"><span class="c1">Vaslui=dict(Iasi=92,Urziceni=142),</span></p><p class="c0"><span class="c1">Zerind=dict(Oradea=71,Arad=75)</span></p><p class="c0"><span class="c1">)</span></p><p class="c0"><span class="c1">Prac4.py</span></p><p class="c0"><span class="c1">import queue as Q</span></p><p class="c0"><span class="c1">from RMP import dict_gn</span></p><p class="c0"><span class="c1">from RMP import dict_hn</span></p><p class="c0"><span class="c1">start=&#39;Arad&#39;</span></p><p class="c0"><span class="c1">goal=&#39;Bucharest&#39;</span></p><p class="c0"><span class="c1">result=&#39;&#39;</span></p><p class="c0"><span class="c1">def get_fn(citystr):</span></p><p class="c0"><span class="c1">cities=citystr.split(&#39;,&#39;)</span></p><p class="c0"><span class="c1">hn=gn=0</span></p><p class="c0"><span class="c1">for ctr in range(0,len(cities)-1):</span></p><p class="c0"><span class="c1">gn=gn+dict_gn[cities[ctr]][cities[ctr+1]]</span></p><p class="c0"><span class="c1">hn=dict_hn[cities[len(cities)-1]]</span></p><p class="c0"><span class="c1">return(hn+gn)</span></p><p class="c0"><span class="c1">def printout(cityq):</span></p><p class="c0"><span class="c1">for i in range(0,cityq.qsize()):</span></p><p class="c0"><span class="c1">print(cityq.queue[i])</span></p><p class="c0"><span class="c1">def expand(cityq):</span></p><p class="c0"><span class="c1">global result</span></p><p class="c0"><span class="c1">tot,citystr,thiscity=cityq.get()</span></p><p class="c0"><span class="c1">nexttot=999</span></p><p class="c0"><span class="c1">if not cityq.empty():</span></p><p class="c0"><span class="c1">nexttot,nextcitystr,nextthiscity=cityq.queue[0]</span></p><p class="c0"><span class="c1">if thiscity==goal and tot&lt;nexttot:</span></p><p class="c0"><span class="c1">result=citystr+&#39;::&#39;+str(tot)</span></p><p class="c0"><span class="c1">return</span></p><p class="c0"><span class="c1">print(&quot;Expanded city------------------------------&quot;,thiscity)</span></p><p class="c0"><span class="c1">print(&quot;Second best f(n)------------------------------&quot;,nexttot)</span></p><p class="c0"><span class="c1">tempq=Q.PriorityQueue()</span></p><p class="c0"><span class="c1">for cty in dict_gn[thiscity]:</span></p><p class="c0"><span class="c1">tempq.put((get_fn(citystr+&#39;,&#39;+cty),citystr+&#39;,&#39;+cty,cty))</span></p><p class="c0"><span class="c1">for ctr in range(1,3):</span></p><p class="c0"><span class="c1">ctrtot,ctrcitystr,ctrthiscity=tempq.get()</span></p><p class="c0"><span class="c1">if ctrtot&lt;nexttot:</span></p><p class="c0"><span class="c1">cityq.put((ctrtot,ctrcitystr,ctrthiscity))</span></p><p class="c0"><span class="c1">else:</span></p><p class="c0"><span class="c1">cityq.put((ctrtot,citystr,thiscity))</span></p><p class="c0"><span class="c1">break</span></p><p class="c0"><span class="c1">printout(cityq)</span></p><p class="c0"><span class="c1">expand(cityq)</span></p><p class="c0"><span class="c1">def main():</span></p><p class="c0"><span class="c1">cityq=Q.PriorityQueue()</span></p><p class="c0"><span class="c1">thiscity=start</span></p><p class="c0"><span class="c1">cityq.put((999,&quot;NA&quot;,&quot;NA&quot;))</span></p><p class="c0"><span class="c1">cityq.put((get_fn(start),start,thiscity))</span></p><p class="c0"><span class="c1">expand(cityq)</span></p><p class="c0"><span class="c1">print(result)</span></p><p class="c0"><span class="c1">main()</span></p><p class="c0"><span class="c1">OUTPUT:</span></p><p class="c0"><span class="c1">Expanded city------------------------------ Arad</span></p><p class="c0"><span class="c1">Second best f(n)------------------------------ 999</span></p><p class="c0"><span class="c1">(393, &#39;Arad,Sibiu&#39;, &#39;Sibiu&#39;)</span></p><p class="c0"><span class="c1">(999, &#39;NA&#39;, &#39;NA&#39;)</span></p><p class="c0"><span class="c1">(447, &#39;Arad,Timisoara&#39;, &#39;Timisoara&#39;)</span></p><p class="c0"><span class="c1">Expanded city------------------------------ Sibiu</span></p><p class="c0"><span class="c1">Second best f(n)------------------------------ 447</span></p><p class="c0"><span class="c1">(413, &#39;Arad,Sibiu,Rimnicu&#39;, &#39;Rimnicu&#39;)</span></p><p class="c0"><span class="c1">(415, &#39;Arad,Sibiu,Fagaras&#39;, &#39;Fagaras&#39;)</span></p><p class="c0"><span class="c1">(447, &#39;Arad,Timisoara&#39;, &#39;Timisoara&#39;)</span></p><p class="c0"><span class="c1">(999, &#39;NA&#39;, &#39;NA&#39;)</span></p><p class="c0"><span class="c1">Expanded city------------------------------ Rimnicu</span></p><p class="c0"><span class="c1">Second best f(n)------------------------------ 415</span></p><p class="c0"><span class="c1">(415, &#39;Arad,Sibiu,Fagaras&#39;, &#39;Fagaras&#39;)</span></p><p class="c0"><span class="c1">(417, &#39;Arad,Sibiu,Rimnicu&#39;, &#39;Rimnicu&#39;)</span></p><p class="c0"><span class="c1">(447, &#39;Arad,Timisoara&#39;, &#39;Timisoara&#39;)</span></p><p class="c0"><span class="c1">(999, &#39;NA&#39;, &#39;NA&#39;)</span></p><p class="c0"><span class="c1">Expanded city------------------------------ Fagaras</span></p><p class="c0"><span class="c1">Second best f(n)------------------------------ 417</span></p><p class="c0"><span class="c1">(417, &#39;Arad,Sibiu,Rimnicu&#39;, &#39;Rimnicu&#39;)</span></p><p class="c0"><span class="c1">(450, &#39;Arad,Sibiu,Fagaras&#39;, &#39;Fagaras&#39;)</span></p><p class="c0"><span class="c1">(447, &#39;Arad,Timisoara&#39;, &#39;Timisoara&#39;)</span></p><p class="c0"><span class="c1">(999, &#39;NA&#39;, &#39;NA&#39;)</span></p><p class="c0"><span class="c1">Expanded city------------------------------ Rimnicu</span></p><p class="c0"><span class="c1">Second best f(n)------------------------------ 447</span></p><p class="c0"><span class="c1">(417, &#39;Arad,Sibiu,Rimnicu,Pitesti&#39;, &#39;Pitesti&#39;)</span></p><p class="c0"><span class="c1">(447, &#39;Arad,Timisoara&#39;, &#39;Timisoara&#39;)</span></p><p class="c0"><span class="c1">(999, &#39;NA&#39;, &#39;NA&#39;)</span></p><p class="c0"><span class="c1">(450, &#39;Arad,Sibiu,Fagaras&#39;, &#39;Fagaras&#39;)</span></p><p class="c0"><span class="c1">(526, &#39;Arad,Sibiu,Rimnicu&#39;, &#39;Rimnicu&#39;)</span></p><p class="c0"><span class="c1">Expanded city------------------------------ Pitesti</span></p><p class="c0"><span class="c1">Second best f(n)------------------------------ 447</span></p><p class="c0"><span class="c1">(418, &#39;Arad,Sibiu,Rimnicu,Pitesti,Bucharest&#39;, &#39;Bucharest&#39;)</span></p><p class="c0"><span class="c1">(447, &#39;Arad,Timisoara&#39;, &#39;Timisoara&#39;)</span></p><p class="c0"><span class="c1">(607, &#39;Arad,Sibiu,Rimnicu,Pitesti&#39;, &#39;Pitesti&#39;)</span></p><p class="c0"><span class="c1">(526, &#39;Arad,Sibiu,Rimnicu&#39;, &#39;Rimnicu&#39;)</span></p><p class="c0"><span class="c1">(450, &#39;Arad,Sibiu,Fagaras&#39;, &#39;Fagaras&#39;)</span></p><p class="c0"><span class="c1">(999, &#39;NA&#39;, &#39;NA&#39;)</span></p><p class="c0"><span class="c1">Arad,Sibiu,Rimnicu,Pitesti,Bucharest::418</span></p><p class="c0"><span class="c1">PRACTICAL NO-5</span></p><p class="c0"><span class="c1">AIM: Implement Decision-Tree learning algorithm.</span></p><p class="c0"><span class="c1">#REQUIREMENTS:</span></p><p class="c0"><span class="c1">1)---file1(balance-scale.data) &amp; file2(balance-scale.names)</span></p><p class="c0"><span class="c1">2)---install these modules:</span></p><p class="c0"><span class="c1">python -m pip install pandas==0.18</span></p><p class="c0"><span class="c1">python -m pip install scipy</span></p><p class="c0"><span class="c1">python -m pip install scikit-learn</span></p><p class="c0"><span class="c1">python -m pip install numpy</span></p><p class="c0"><span class="c1">prac5.py</span></p><p class="c0"><span class="c1">import numpy as np</span></p><p class="c0"><span class="c1">import pandas as pd</span></p><p class="c0"><span class="c1">import sklearn as sk</span></p><p class="c0"><span class="c1">from sklearn.metrics import confusion_matrix</span></p><p class="c0"><span class="c1">from sklearn.model_selection import train_test_split</span></p><p class="c0"><span class="c1">from sklearn.tree import DecisionTreeClassifier</span></p><p class="c0"><span class="c1">from sklearn.metrics import accuracy_score</span></p><p class="c0"><span class="c1">from sklearn.metrics import classification_report</span></p><p class="c0"><span class="c1">#func importing dataset</span></p><p class="c0"><span class="c1">def importdata():</span></p><p class="c0"><span class="c1">balance_data=pd.read_csv(&quot;balance-scale.data&quot;)</span></p><p class="c0"><span class="c1">#print the dataset shape</span></p><p class="c0"><span class="c1">print(&quot;Dataset Length : &quot;,len(balance_data))</span></p><p class="c0"><span class="c1">#printing the dataset observations</span></p><p class="c0"><span class="c1">print(&quot;Dataset : &quot;,balance_data.head())</span></p><p class="c0"><span class="c1">return balance_data</span></p><p class="c0"><span class="c1">#func to split the dataset</span></p><p class="c0"><span class="c1">def splitdataset(balance_data):</span></p><p class="c0"><span class="c1">#seperating the target variable</span></p><p class="c0"><span class="c1">X=balance_data.values[:,1:5]</span></p><p class="c0"><span class="c1">Y=balance_data.values[:,0]</span></p><p class="c0"><span class="c1">#splitting the dataset into train and test</span></p><p class="c0"><span class="c1">X_train,X_test,y_train,y_test=train_test_split(X,Y,test_size=0.3,random_state=100)</span></p><p class="c0"><span class="c1">return X,Y,X_train,X_test,y_train,y_test</span></p><p class="c0"><span class="c1">#function to perform training with entropy</span></p><p class="c0"><span class="c1">def train_using_entropy(X_train,X_test,y_train,y_test):</span></p><p class="c0"><span class="c1">#decision tree with entropy</span></p><p class="c0"><span class="c1">clf_entropy=DecisionTreeClassifier(criterion=&quot;entropy&quot;,random_state=100,max_depth=3,min_samples_leaf=5)</span></p><p class="c0"><span class="c1">#performing training</span></p><p class="c0"><span class="c1">clf_entropy.fit(X_train,y_train)</span></p><p class="c0"><span class="c1">return clf_entropy</span></p><p class="c0"><span class="c1">def prediction(X_test,clf_object):</span></p><p class="c0"><span class="c1">y_pred=clf_object.predict(X_test)</span></p><p class="c0"><span class="c1">print(&quot;Predicted Values : &quot;)</span></p><p class="c0"><span class="c1">print(y_pred)</span></p><p class="c0"><span class="c1">return y_pred</span></p><p class="c0"><span class="c1">def cal_accuracy(y_test,y_pred):</span></p><p class="c0"><span class="c1">print(&quot;Accuracy : &quot;,accuracy_score(y_test,y_pred)*100)</span></p><p class="c0"><span class="c1">def main():</span></p><p class="c0"><span class="c1">data=importdata()</span></p><p class="c0"><span class="c1">X,Y,X_train,X_test,y_train,y_test=splitdataset(data)</span></p><p class="c0"><span class="c1">clf_entropy=train_using_entropy(X_train,X_test,y_train,y_test)</span></p><p class="c0"><span class="c1">print(&quot;Results using entropy : &quot;)</span></p><p class="c0"><span class="c1">y_pred_entropy=prediction(X_test,clf_entropy)</span></p><p class="c0"><span class="c1">cal_accuracy(y_test,y_pred_entropy)</span></p><p class="c0"><span class="c1">main()</span></p><p class="c0"><span class="c1">OUTPUT:</span></p><p class="c0"><span class="c1">Dataset Length : 624</span></p><p class="c0"><span class="c1">Dataset : B 1 1.1 1.2 1.3</span></p><p class="c0"><span class="c1">0 R 1 1 1 2</span></p><p class="c0"><span class="c1">1 R 1 1 1 3</span></p><p class="c0"><span class="c1">2 R 1 1 1 4</span></p><p class="c0"><span class="c1">3 R 1 1 1 5</span></p><p class="c0"><span class="c1">4 R 1 1 2 1</span></p><p class="c0"><span class="c1">Results using entropy :</span></p><p class="c0"><span class="c1">Predicted Values :</span></p><p class="c0"><span class="c1">[&#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;L&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39;</span></p><p class="c0"><span class="c1">&#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39; &#39;R&#39;</span></p><p class="c0"><span class="c1">&#39;R&#39; &#39;R&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;L&#39; &#39;R&#39; &#39;R&#39;]</span></p><p class="c0"><span class="c1">Accuracy : 66.48936170212765</span></p><p class="c0"><span class="c1">PRACTICAL NO-6</span></p><p class="c0"><span class="c1">AIM: Implement Naive-Bayes learning algo for RWP(Restaurant Waiting Problem).</span></p><p class="c0"><span class="c1">Requirement:</span></p><p class="c0"><span class="c1">RWP.py</span></p><p class="c0"><span class="c1">rwp_examples = dict(</span></p><p class="c0"><span class="c1">x1=dict(Alt=&#39;Y&#39;, Bar=&#39;N&#39;, Fri=&#39;N&#39;,Hun=&#39;Y&#39;,Pat=&#39;S&#39;,Price=&#39;$$$&#39;,Rain=&#39;N&#39;,Res=&#39;Y&#39;,Type=&#39;F&#39;,Est=&#39;0-10&#39;,ans=&#39;Y&#39;),</span></p><p class="c0"><span class="c1">x2=dict(Alt=&#39;Y&#39;, Bar=&#39;N&#39;, Fri=&#39;N&#39;,Hun=&#39;Y&#39;,Pat=&#39;F&#39;,Price=&#39;$&#39;,Rain=&#39;N&#39;,Res=&#39;N&#39;,Type=&#39;T&#39;,Est=&#39;30-60&#39;,ans=&#39;N&#39;),</span></p><p class="c0"><span class="c1">x3=dict(Alt=&#39;N&#39;, Bar=&#39;Y&#39;, Fri=&#39;N&#39;,Hun=&#39;N&#39;,Pat=&#39;S&#39;,Price=&#39;$&#39;,Rain=&#39;N&#39;,Res=&#39;N&#39;,Type=&#39;B&#39;,Est=&#39;0-10&#39;,ans=&#39;Y&#39;),</span></p><p class="c0"><span class="c1">x4=dict(Alt=&#39;Y&#39;, Bar=&#39;N&#39;, Fri=&#39;Y&#39;,Hun=&#39;Y&#39;,Pat=&#39;F&#39;,Price=&#39;$&#39;,Rain=&#39;Y&#39;,Res=&#39;N&#39;,Type=&#39;T&#39;,Est=&#39;10-30&#39;,ans=&#39;Y&#39;),</span></p><p class="c0"><span class="c1">x5=dict(Alt=&#39;Y&#39;, Bar=&#39;N&#39;, Fri=&#39;Y&#39;,Hun=&#39;N&#39;,Pat=&#39;F&#39;,Price=&#39;$$$&#39;,Rain=&#39;N&#39;,Res=&#39;Y&#39;,Type=&#39;F&#39;,Est=&#39;&gt;60&#39;,ans=&#39;N&#39;),</span></p><p class="c0"><span class="c1">x6=dict(Alt=&#39;N&#39;, Bar=&#39;Y&#39;, Fri=&#39;N&#39;,Hun=&#39;Y&#39;,Pat=&#39;S&#39;,Price=&#39;$$&#39;,Rain=&#39;Y&#39;,Res=&#39;Y&#39;,Type=&#39;I&#39;,Est=&#39;0-10&#39;,ans=&#39;Y&#39;),</span></p><p class="c0"><span class="c1">x7=dict(Alt=&#39;N&#39;, Bar=&#39;Y&#39;, Fri=&#39;N&#39;,Hun=&#39;N&#39;,Pat=&#39;N&#39;,Price=&#39;$&#39;,Rain=&#39;Y&#39;,Res=&#39;N&#39;,Type=&#39;B&#39;,Est=&#39;0-10&#39;,ans=&#39;N&#39;),</span></p><p class="c0"><span class="c1">x8=dict(Alt=&#39;N&#39;, Bar=&#39;N&#39;, Fri=&#39;N&#39;,Hun=&#39;Y&#39;,Pat=&#39;S&#39;,Price=&#39;$$&#39;,Rain=&#39;Y&#39;,Res=&#39;Y&#39;,Type=&#39;T&#39;,Est=&#39;0-10&#39;,ans=&#39;Y&#39;),</span></p><p class="c0"><span class="c1">x9=dict(Alt=&#39;N&#39;, Bar=&#39;Y&#39;, Fri=&#39;Y&#39;,Hun=&#39;N&#39;,Pat=&#39;F&#39;,Price=&#39;$&#39;,Rain=&#39;Y&#39;,Res=&#39;N&#39;,Type=&#39;B&#39;,Est=&#39;&gt;60&#39;,ans=&#39;N&#39;),</span></p><p class="c0"><span class="c1">x10=dict(Alt=&#39;Y&#39;, Bar=&#39;Y&#39;, Fri=&#39;Y&#39;,Hun=&#39;Y&#39;,Pat=&#39;F&#39;,Price=&#39;$$$&#39;,Rain=&#39;N&#39;,Res=&#39;Y&#39;,Type=&#39;I&#39;,Est=&#39;10-30&#39;,ans=&#39;N&#39;),</span></p><p class="c0"><span class="c1">x11=dict(Alt=&#39;N&#39;, Bar=&#39;N&#39;, Fri=&#39;N&#39;,Hun=&#39;N&#39;,Pat=&#39;N&#39;,Price=&#39;$&#39;,Rain=&#39;N&#39;,Res=&#39;N&#39;,Type=&#39;T&#39;,Est=&#39;0-10&#39;,ans=&#39;N&#39;),</span></p><p class="c0"><span class="c1">x12=dict(Alt=&#39;Y&#39;, Bar=&#39;Y&#39;, Fri=&#39;Y&#39;,Hun=&#39;Y&#39;,Pat=&#39;F&#39;,Price=&#39;$&#39;,Rain=&#39;N&#39;,Res=&#39;N&#39;,Type=&#39;B&#39;,Est=&#39;0-10&#39;,ans=&#39;Y&#39;)</span></p><p class="c0"><span class="c1">)</span></p><p class="c0"><span class="c1">Prac6.py</span></p><p class="c0"><span class="c1">from RWP import rwp_examples</span></p><p class="c0"><span class="c1">total_exp = 12</span></p><p class="c0"><span class="c1">def tot(attribute, value):</span></p><p class="c0"><span class="c1">count = 0</span></p><p class="c0"><span class="c1">for key, val in rwp_examples.items():</span></p><p class="c0"><span class="c1">for key1, val1 in val.items():</span></p><p class="c0"><span class="c1">if key1 == attribute:</span></p><p class="c0"><span class="c1">if val1 == value:</span></p><p class="c0"><span class="c1">count += 1</span></p><p class="c0"><span class="c1">return count</span></p><p class="c0"><span class="c1">def getProbab(attribute, attribval, value):</span></p><p class="c0"><span class="c1">count = 0</span></p><p class="c0"><span class="c1">for key, val in rwp_examples.items():</span></p><p class="c0"><span class="c1">val1 = rwp_examples[key][attribute]</span></p><p class="c0"><span class="c1">val2 = rwp_examples[key][&#39;ans&#39;]</span></p><p class="c0"><span class="c1">if val1 == attribval and val2 == value:</span></p><p class="c0"><span class="c1">count += 1</span></p><p class="c0"><span class="c1">probab = count / tot(&#39;ans&#39;, value)</span></p><p class="c0"><span class="c1">return probab</span></p><p class="c0"><span class="c1">def main():</span></p><p class="c0"><span class="c1">PAltYes = tot(&#39;Alt&#39;, &#39;Y&#39;) / total_exp</span></p><p class="c0"><span class="c1">PAltNo = tot(&#39;Alt&#39;, &#39;N&#39;) / total_exp</span></p><p class="c0"><span class="c1">PBarYes = tot(&#39;Bar&#39;, &#39;Y&#39;) / total_exp</span></p><p class="c0"><span class="c1">PBarNo = tot(&#39;Bar&#39;, &#39;N&#39;) / total_exp</span></p><p class="c0"><span class="c1">PFriYes = tot(&#39;Fri&#39;, &#39;Y&#39;) / total_exp</span></p><p class="c0"><span class="c1">PFriNo = tot(&#39;Fri&#39;, &#39;N&#39;) / total_exp</span></p><p class="c0"><span class="c1">PHunYes = tot(&#39;Hun&#39;, &#39;Y&#39;) / total_exp</span></p><p class="c0"><span class="c1">PHunNo = tot(&#39;Hun&#39;, &#39;N&#39;) / total_exp</span></p><p class="c0"><span class="c1">PPatSome = tot(&#39;Pat&#39;, &#39;S&#39;) / total_exp</span></p><p class="c0"><span class="c1">PPatFull = tot(&#39;Pat&#39;, &#39;F&#39;) / total_exp</span></p><p class="c0"><span class="c1">PPatNone = tot(&#39;Pat&#39;, &#39;N&#39;) / total_exp</span></p><p class="c0"><span class="c1">PPriceCheap = tot(&#39;Price&#39;, &#39;$&#39;) / total_exp</span></p><p class="c0"><span class="c1">PPriceAvg = tot(&#39;Price&#39;, &#39;$$&#39;) / total_exp</span></p><p class="c0"><span class="c1">PPriceExp = tot(&#39;Price&#39;, &#39;$$$&#39;) / total_exp</span></p><p class="c0"><span class="c1">PRainYes = tot(&#39;Rain&#39;, &#39;Y&#39;) / total_exp</span></p><p class="c0"><span class="c1">PRainNo = tot(&#39;Rain&#39;, &#39;N&#39;) / total_exp</span></p><p class="c0"><span class="c1">PResYes = tot(&#39;Res&#39;, &#39;Y&#39;) / total_exp</span></p><p class="c0"><span class="c1">PResNo = tot(&#39;Res&#39;, &#39;N&#39;) / total_exp</span></p><p class="c0"><span class="c1">PTypeFrench = tot(&#39;Type&#39;, &#39;F&#39;) / total_exp</span></p><p class="c0"><span class="c1">PTypeItalian = tot(&#39;Type&#39;, &#39;I&#39;) / total_exp</span></p><p class="c0"><span class="c1">PTypeBurger = tot(&#39;Type&#39;, &#39;B&#39;) / total_exp</span></p><p class="c0"><span class="c1">PTypeThai = tot(&#39;Type&#39;, &#39;T&#39;) / total_exp</span></p><p class="c0"><span class="c1">PEstFew = tot(&#39;Est&#39;, &#39;0-10&#39;) / total_exp</span></p><p class="c0"><span class="c1">PEstMore = tot(&#39;Est&#39;, &#39;10-30&#39;) / total_exp</span></p><p class="c0"><span class="c1">PEstStillMore = tot(&#39;Est&#39;, &#39;30-60&#39;) / total_exp</span></p><p class="c0"><span class="c1">PEstTooMuch = tot(&#39;Est&#39;, &#39;&gt;60&#39;) / total_exp</span></p><p class="c0"><span class="c1">PAnsYes = tot(&#39;ans&#39;, &#39;Y&#39;) / total_exp</span></p><p class="c0"><span class="c1">PAnsNo = tot(&#39;ans&#39;, &#39;N&#39;) / total_exp</span></p><p class="c0"><span class="c1">print(&#39;Probability for will wait if there is an Alternate Restaurant Nearby: &#39;)</span></p><p class="c0"><span class="c1">print(&#39;Yes: Will Wait &#39;, (getProbab(&#39;Alt&#39;, &#39;Y&#39;, &#39;Y&#39;) * PAnsYes/PAltYes) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;No: Will Wait &#39;, (getProbab(&#39;Alt&#39;, &#39;Y&#39;, &#39;N&#39;) * PAnsNo/PAltYes ) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;Probability for will wait if there No is an Alternate Restaurant Nearby: &#39;)</span></p><p class="c0"><span class="c1">print(&#39;Yes: Will Wait &#39;, (getProbab(&#39;Alt&#39;, &#39;N&#39;, &#39;Y&#39;) * PAnsYes/PAltNo) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;No: Will Wait &#39;, (getProbab(&#39;Alt&#39;, &#39;N&#39;, &#39;N&#39;) * PAnsNo/PAltNo) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;Probability for will wait if Estimated Wait time is 0-10 minutes: &#39;)</span></p><p class="c0"><span class="c1">print(&#39;Yes: Will Wait &#39;, (getProbab(&#39;Est&#39;, &#39;0-10&#39;, &#39;Y&#39;) * PAnsYes/PEstFew) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;No: Will Wait &#39;, (getProbab(&#39;Est&#39;, &#39;0-10&#39;, &#39;N&#39;) * PAnsNo/PEstFew) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;Probability for will wait if Estimated Wait time is 10-30 minutes &#39;)</span></p><p class="c0"><span class="c1">print(&#39;Yes: Will Wait &#39;, (getProbab(&#39;Est&#39;, &#39;10-30&#39;, &#39;Y&#39;) * PAnsYes/PEstMore) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;No: Will Wait &#39;, (getProbab(&#39;Est&#39;, &#39;10-30&#39;, &#39;N&#39;) * PAnsNo/PEstMore) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&quot;Probability for Will Wait if the Estimated Wait Time is 30-60 mins: &quot;)</span></p><p class="c0"><span class="c1">print(&quot;Yes: Will Wait: &quot;,(getProbab(&#39;Est&#39;,&#39;30-60&#39;,&#39;Y&#39;)*PAnsYes/PEstStillMore)*100,&quot;%&quot;)</span></p><p class="c0"><span class="c1">print(&quot;No: Will Wait: &quot;,(getProbab(&#39;Est&#39;,&#39;30-60&#39;,&#39;N&#39;)*PAnsNo/PEstStillMore)*100,&quot;%&quot;)</span></p><p class="c0"><span class="c1">print(&quot;Probability for Will Wait if the Estimated Wait Time is &gt;60 mins: &quot;)</span></p><p class="c0"><span class="c1">print(&quot;Yes: Will Wait: &quot;,(getProbab(&#39;Est&#39;,&#39;&gt;60&#39;,&#39;Y&#39;)*PAnsYes/PEstTooMuch)*100,&quot;%&quot;)</span></p><p class="c0"><span class="c1">print(&quot;No: Will Wait: &quot;,(getProbab(&#39;Est&#39;,&#39;&gt;60&#39;,&#39;N&#39;)*PAnsNo/PEstTooMuch)*100,&quot;%&quot;)</span></p><p class="c0"><span class="c1">print(&#39;Probability for will wait if there are Some Patrons &#39;)</span></p><p class="c0"><span class="c1">print(&#39;Yes: Will Wait &#39;, (getProbab(&#39;Pat&#39;, &#39;S&#39;, &#39;Y&#39;) * PAnsYes/PPatSome) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;No: Will Wait &#39;, (getProbab(&#39;Pat&#39;, &#39;S&#39;, &#39;N&#39;) * PAnsNo/PPatSome) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&quot;Probability for Will Wait if there are None Patrons: &quot;)</span></p><p class="c0"><span class="c1">print(&quot;Yes: Will Wait: &quot;,(getProbab(&#39;Pat&#39;,&#39;N&#39;,&#39;Y&#39;)*PAnsYes/PPatNone)*100,&quot;%&quot;)</span></p><p class="c0"><span class="c1">print(&quot;No: Will Wait: &quot;,(getProbab(&#39;Pat&#39;,&#39;N&#39;,&#39;N&#39;)*PAnsNo/PPatNone)*100,&quot;%&quot;)</span></p><p class="c0"><span class="c1">print(&quot;Probability for Will Wait if there are Full Patrons: &quot;)</span></p><p class="c0"><span class="c1">print(&quot;Yes: Will Wait: &quot;,(getProbab(&#39;Pat&#39;,&#39;F&#39;,&#39;Y&#39;)*PAnsYes/PPatFull)*100,&quot;%&quot;)</span></p><p class="c0"><span class="c1">print(&quot;No: Will Wait: &quot;,(getProbab(&#39;Pat&#39;,&#39;F&#39;,&#39;N&#39;)*PAnsNo/PPatFull)*100,&quot;%&quot;)</span></p><p class="c0"><span class="c1">print(&#39;Probability for will wait if the place is Thai &#39;)</span></p><p class="c0"><span class="c1">print(&#39;Yes: Will Wait &#39;, (getProbab(&#39;Type&#39;, &#39;T&#39;, &#39;Y&#39;) * PAnsYes/PTypeThai) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">print(&#39;No: Will Wait &#39;, (getProbab(&#39;Type&#39;, &#39;T&#39;, &#39;N&#39;) * PAnsNo/PTypeThai) * 100, &#39;%&#39;)</span></p><p class="c0"><span class="c1">main()</span></p><p class="c0"><span class="c1">OUTPUT:</span></p><p class="c0"><span class="c1">Probability for will wait if there is an Alternate Restaurant Nearby:</span></p><p class="c0"><span class="c1">Yes: Will Wait 50.0 %</span></p><p class="c0"><span class="c1">No: Will Wait 50.0 %</span></p><p class="c0"><span class="c1">Probability for will wait if there No is an Alternate Restaurant Nearby:</span></p><p class="c0"><span class="c1">Yes: Will Wait 50.0 %</span></p><p class="c0"><span class="c1">No: Will Wait 50.0 %</span></p><p class="c0"><span class="c1">Probability for will wait if Estimated Wait time is 0-10 minutes:</span></p><p class="c0"><span class="c1">Yes: Will Wait 71.42857142857143 %</span></p><p class="c0"><span class="c1">No: Will Wait 28.57142857142857 %</span></p><p class="c0"><span class="c1">Probability for will wait if Estimated Wait time is 10-30 minutes</span></p><p class="c0"><span class="c1">Yes: Will Wait 50.0 %</span></p><p class="c0"><span class="c1">No: Will Wait 50.0 %</span></p><p class="c0"><span class="c1">Probability for Will Wait if the Estimated Wait Time is 30-60 mins:</span></p><p class="c0"><span class="c1">Yes: Will Wait: 0.0 %</span></p><p class="c0"><span class="c1">No: Will Wait: 100.0 %</span></p><p class="c0"><span class="c1">Probability for Will Wait if the Estimated Wait Time is &gt;60 mins:</span></p><p class="c0"><span class="c1">Yes: Will Wait: 0.0 %</span></p><p class="c0"><span class="c1">No: Will Wait: 100.0 %</span></p><p class="c0"><span class="c1">Probability for will wait if there are Some Patrons</span></p><p class="c0"><span class="c1">Yes: Will Wait 100.0 %</span></p><p class="c0"><span class="c1">No: Will Wait 0.0 %</span></p><p class="c0"><span class="c1">Probability for Will Wait if there are None Patrons:</span></p><p class="c0"><span class="c1">Yes: Will Wait: 0.0 %</span></p><p class="c0"><span class="c1">No: Will Wait: 100.0 %</span></p><p class="c0"><span class="c1">Probability for Will Wait if there are Full Patrons:</span></p><p class="c0"><span class="c1">Yes: Will Wait: 33.33333333333333 %</span></p><p class="c0"><span class="c1">No: Will Wait: 66.66666666666666 %</span></p><p class="c0"><span class="c1">Probability for will wait if the place is Thai</span></p><p class="c0"><span class="c1">Yes: Will Wait 50.0 %</span></p><p class="c0"><span class="c1">No: Will Wait 50.0 %</span></p><p class="c0"><span class="c1">PRACTICAL NO-7</span></p><p class="c0"><span class="c1">AIM: Implement feed forward back propagation neural network learning algorithm.</span></p><p class="c0"><span class="c1">import numpy as np</span></p><p class="c0"><span class="c1">class NeuralNetwork():</span></p><p class="c0"><span class="c1">def __init__(self):</span></p><p class="c0"><span class="c1">#seeding for random number generation</span></p><p class="c0"><span class="c1">np.random.seed()</span></p><p class="c0"><span class="c1">#converting weights to a 3 by 1 matrix</span></p><p class="c0"><span class="c1">self.synaptic_weights=2*np.random.random((3,1))-1</span></p><p class="c0"><span class="c1">#x is output variable</span></p><p class="c0"><span class="c1">def sigmoid(self, x):</span></p><p class="c0"><span class="c1">#applying the sigmoid function</span></p><p class="c0"><span class="c1">return 1/(1+np.exp(-x))</span></p><p class="c0"><span class="c1">def sigmoid_derivative(self,x):</span></p><p class="c0"><span class="c1">#computing derivative to the sigmoid function</span></p><p class="c0"><span class="c1">return x*(1-x)</span></p><p class="c0"><span class="c1">def train(self,training_inputs,training_outputs,training_iterations):</span></p><p class="c0"><span class="c1">#training the model to make accurate predictions while adjusting</span></p><p class="c0"><span class="c1">for iteration in range(training_iterations):</span></p><p class="c0"><span class="c1">#siphon the training data via the neuron</span></p><p class="c0"><span class="c1">output=self.think(training_inputs)</span></p><p class="c0"><span class="c1">error=training_outputs-output</span></p><p class="c0"><span class="c1">#performing weight adjustments</span></p><p class="c0"><span class="c1">adjustments=np.dot(training_inputs.T,error*self.sigmoid_derivative(output))</span></p><p class="c0"><span class="c1">self.synaptic_weights+=adjustments</span></p><p class="c0"><span class="c1">def think(self,inputs):</span></p><p class="c0"><span class="c1">#passing the inputs via the neuron to get output</span></p><p class="c0"><span class="c1">#converting values to floats</span></p><p class="c0"><span class="c1">inputs=inputs.astype(float)</span></p><p class="c0"><span class="c1">output=self.sigmoid(np.dot(inputs,self.synaptic_weights))</span></p><p class="c0"><span class="c1">return output</span></p><p class="c0"><span class="c1">if __name__==&quot;__main__&quot;:</span></p><p class="c0"><span class="c1">#initializing the neuron class</span></p><p class="c0"><span class="c1">neural_network=NeuralNetwork()</span></p><p class="c0"><span class="c1">print(&quot;Beginning randomly generated weights: &quot;)</span></p><p class="c0"><span class="c1">print(neural_network.synaptic_weights)</span></p><p class="c0"><span class="c1">#training data consisting of 4 examples--3 inputs &amp; 1 output</span></p><p class="c0"><span class="c1">training_inputs=np.array([[0,0,1],[1,1,1],[1,0,1],[0,1,1]])</span></p><p class="c0"><span class="c1">training_outputs=np.array([[0,1,1,0]]).T</span></p><p class="c0"><span class="c1">#training taking place</span></p><p class="c0"><span class="c1">neural_network.train(training_inputs,training_outputs,15000)</span></p><p class="c0"><span class="c1">print(&quot;Ending weights after training: &quot;)</span></p><p class="c0"><span class="c1">print(neural_network.synaptic_weights)</span></p><p class="c0"><span class="c1">user_input_one=str(input(&quot;User Input One: &quot;))</span></p><p class="c0"><span class="c1">user_input_two=str(input(&quot;User Input Two: &quot;))</span></p><p class="c0"><span class="c1">user_input_three=str(input(&quot;User Input Three: &quot;))</span></p><p class="c0"><span class="c1">print(&quot;Considering new situation: &quot;,user_input_one,user_input_two,user_input_three)</span></p><p class="c0"><span class="c1">print(&quot;New output data: &quot;)</span></p><p class="c0"><span class="c1">print(neural_network.think(np.array([user_input_one,user_input_two,user_input_three])))</span></p><p class="c0"><span class="c1">OUTPUT:</span></p><p class="c0"><span class="c1">Beginning randomly generated weights:</span></p><p class="c0"><span class="c1">[[-0.89078318]</span></p><p class="c0"><span class="c1">[-0.34733271]</span></p><p class="c0"><span class="c1">[-0.49265857]]</span></p><p class="c0"><span class="c1">Ending weights after training:</span></p><p class="c0"><span class="c1">[[10.08710295]</span></p><p class="c0"><span class="c1">[-0.20735667]</span></p><p class="c0"><span class="c1">[-4.83718482]]</span></p><p class="c0"><span class="c1">User Input One: 6</span></p><p class="c0"><span class="c1">User Input Two: 8</span></p><p class="c0"><span class="c1">User Input Three: 12</span></p><p class="c0"><span class="c1">Considering new situation: 6 8 12</span></p><p class="c0"><span class="c1">New output data:</span></p><p class="c0"><span class="c1">[0.69371529]</span></p><p class="c0"><span class="c1">PRACTICAL NO-8</span></p><p class="c0"><span class="c1">AIM: Implement AdaBoost(Adaptive Boosting) learning algorithm.</span></p><p class="c0"><span class="c1">import pandas</span></p><p class="c0"><span class="c1">from sklearn import model_selection</span></p><p class="c0"><span class="c1">from sklearn.ensemble import AdaBoostClassifier</span></p><p class="c0"><span class="c1">url = &quot;https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv&quot;</span></p><p class="c0"><span class="c1">names = [&#39;preg&#39;, &#39;plas&#39;, &#39;pres&#39;, &#39;skin&#39;, &#39;test&#39;, &#39;mass&#39;, &#39;pedi&#39;, &#39;age&#39;, &#39;class&#39;]</span></p><p class="c0"><span class="c1">dataframe = pandas.read_csv(url, names=names)</span></p><p class="c0"><span class="c1">array = dataframe.values</span></p><p class="c0"><span class="c1">X = array[:,0:8]</span></p><p class="c0"><span class="c1">Y = array[:,8]</span></p><p class="c0"><span class="c1">seed = 7</span></p><p class="c0"><span class="c1">num_trees = 30</span></p><p class="c0"><span class="c1">#kfold makes trees with split number.</span></p><p class="c0"><span class="c1">#kfold = model_selection.KFold(n_splits=10, random_state=seed)</span></p><p class="c0"><span class="c1">#n_estimators : This is the number of trees you want to build before predictions.</span></p><p class="c0"><span class="c1">#Higher number of trees give you better voting optionsand perfomance performance</span></p><p class="c0"><span class="c1">model = AdaBoostClassifier(n_estimators=num_trees, random_state=seed)</span></p><p class="c0"><span class="c1">#cross_val_score method is used to calculate the accuracy of model sliced into x, y</span></p><p class="c0"><span class="c1">#cross validator cv is optional cv=kfold</span></p><p class="c0"><span class="c1">results = model_selection.cross_val_score(model, X, Y)</span></p><p class="c0"><span class="c1">print(results.mean())</span></p><p class="c0"><span class="c1">OUTPUT will come after seconds:</span></p><p class="c0"><span class="c1">0.755287171613133</span></p></body></html>
